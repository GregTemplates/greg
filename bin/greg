#!/usr/bin/env ruby
require "pathname"
require "erb"
require "fattr"
require "colin"

module Greg
  def self.generator(**options)
    @generator ||= get_generator(**options)
  end

  def self.get_generator(name:, template_name: , output_dir: ".", force: false)
    generator_name = "#{template_name}_generator"
    template = Greg.templates_dir + "/#{template_name}/#{generator_name}"
    if Pathname(template + ".rb").exist?
      require template.to_s
    else
      raise UnexistingTemplateError.new(template_name)
    end
    generator_class_name = generator_name.split("_").map(&:capitalize).join
    generator_class = Kernel.const_get(generator_class_name)
    generator_class.new(name: name,
                        template_name: template_name,
                        output_dir: output_dir,
                        force: force)
  end

  class UnexistingTemplateError < Exception
    attr_reader :template
    def initialize(template)
      @template = template
    end
  end

  class ExistingProjectError < Exception
    attr_reader :dir
    def initialize(dir)
      @dir = dir
    end
  end

  def self.templates_dir
    @templates_dir ||= Pathname("~/.greg_templates").expand_path.to_s
  end

  def self.templates_dir=(new_dir)
    @templates_dir = Pathname(new_dir).expand_path.to_s
  end

  class DirTemplate
    attr_reader :destination
    attr_accessor :generator

    def initialize(destination)
      @destination = destination
    end

    def create!
      generator.inside_dir do
        new_dir = Pathname(destination).expand_path
        new_dir.mkdir unless new_dir.exist?
      end
    end

  end

  class FileTemplate
    attr_accessor :generator
    def create!
      generator.inside_dir do
        current_file = Pathname(destination).expand_path
        current_file.dirname.mkdir unless current_file.dirname.exist?
        current_file.write(contents)
      end
    end

    private

    def initialize(**attrs)
      attrs.each do |attr, value|
        send attr, value
      end
    end

    def self.attribute(attr)
      fattr attr
    end
    private_class_method :attribute

    def template(file)
      Pathname(generator.template_dir + "/" + file).expand_path.read
    end

    def erb(str)
      ERB.new(str).result(instance_eval { binding })
    end
  end

  class Gemfile < FileTemplate
    attr_reader :gems

    def initialize(*gems)
      @gems = gems
    end


    def destination
      "Gemfile"
    end

    def contents
      @contents = []
      @contents << 'source "https://rubygems.org"'
      @contents << nil

      @gems.each do |gem|
        if gem.is_a?(Hash)
          gem_name, gem_options = gem.first
          r = []
          r << "gem \"#{gem_name}\""
          gem_options.each do |key, value|
            r << "#{key.to_sym}: \"#{value.to_s}\""
          end
          @contents << r.join(", ")
        else
          @contents << "gem \"#{gem}\""
        end
      end

      @contents.join("\n")
    end
  end

  class Generator
    attr_reader :name
    attr_reader :template_name
    attr_reader :template_path
    attr_reader :output_dir
    attr_reader :current_dir
    attr_reader :force
    attr_reader :generator

    def initialize(name:, template_name: , output_dir: ".", force: false)
      @template_name = template_name
      @output_dir = Pathname(output_dir + "/" + name).expand_path
      @current_dir = Pathname(".").expand_path

      @force = force
    end

    def run
      create_directory
      create_files
      self
    end

    def files
      []
    end


    def inside_dir(&block)
      Dir.chdir(output_dir, &block)
    end

    def template_dir
      Pathname(Greg.templates_dir + "/" +  template_name).expand_path.to_s
    end

    private

    def create_files
      files.each do |file|
        file.generator = self
        file.create!
      end
    end

    def create_directory
      if output_dir.exist?
        if force
          puts "#{output_dir} exists, removing it."
          output_dir.rmtree
        else
          raise ExistingProjectError.new(output_dir)
        end
      end

      output_dir.mkpath
    end
  end

end

options = Colin::Parser.new(ARGV).named_options([:name, :template_name]).options

if options[:h] || options[:help]
  usage = <<-EOF
Usage:
  greg <project-name> <template-name> [options]

Options:
  --force                    Force creation of project directory (if it already exists, it will be overwriten).
  --output_directory         Select where the new project will be located (current directory by default).
  --templates_dir            Select the source location for templates (~/.greg_templates by default)
  EOF

  puts usage
  exit(0)
end

begin
  Greg.templates_dir = options.delete(:templates_dir) || "~/code/sandbox/greg_templates/"

  gen = Greg.generator(options).run

  def sh(command)
    puts nil, "=== #{command} ==="
    puts `#{command}`
    puts "=" * (8+command.size)
  end

  gen.inside_dir do
    sh "ls -la"
    sh "ls -la app/"
    sh "ls -la public/"
    sh "cat app/TheFruit.rb"
    sh "cat Gemfile"
  end

rescue Greg::UnexistingTemplateError => e
  error = <<-EOF
Error:
  "#{e.template}" template doesn't exist.
  EOF
  puts error

  exit(1)
rescue Greg::ExistingProjectError => e
  error = <<-EOF
Error:
  "#{e.dir}" already exists.
  If you want to overwrite it, use the '--force' option.
  EOF
  puts error

  exit(1)
end
